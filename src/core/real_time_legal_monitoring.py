#!/usr/bin/env python3
"""
MWRASP Real-Time Legal Jurisdiction Monitoring System
Continuous monitoring and alerting for legal barrier effectiveness

This module provides real-time monitoring of:
- Legal barrier activation and effectiveness
- Jurisdiction status changes
- Threat actor response to legal barriers
- Compliance status monitoring
- Automated legal response coordination

Date: August 25, 2025
Version: 1.0 - Real-Time Legal Monitoring
Status: Defensive monitoring for legitimate protection
"""

import asyncio
import json
import time
import logging
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Optional, Tuple, Set, Callable
from enum import Enum
from dataclasses import dataclass, asdict
import hashlib
import secrets
from pathlib import Path
import websockets
import aiohttp
from collections import defaultdict, deque

# Import our legal barrier system
from legal_jurisdiction_control_system import (
    LegalBarrierController, 
    JurisdictionMode, 
    LegalBarrierType,
    LegalBarrierEvent
)

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class MonitoringPriority(Enum):
    """Monitoring priority levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class AlertType(Enum):
    """Types of legal monitoring alerts"""
    BARRIER_ACTIVATION = "barrier_activation"
    BARRIER_BYPASS_ATTEMPT = "barrier_bypass_attempt"
    JURISDICTION_CHANGE = "jurisdiction_change"
    COMPLIANCE_VIOLATION = "compliance_violation"
    LEGAL_CHALLENGE = "legal_challenge"
    EFFECTIVENESS_DEGRADATION = "effectiveness_degradation"
    SYSTEM_ANOMALY = "system_anomaly"

@dataclass
class LegalMonitoringAlert:
    """Alert generated by legal monitoring system"""
    alert_id: str
    timestamp: datetime
    alert_type: AlertType
    priority: MonitoringPriority
    jurisdiction: str
    barrier_type: Optional[LegalBarrierType]
    threat_actor_ip: Optional[str]
    description: str
    automated_response: Optional[str]
    requires_human_review: bool
    legal_implications: str
    recommended_actions: List[str]
    context_data: Dict

@dataclass
class BarrierEffectivenessMetrics:
    """Metrics for legal barrier effectiveness"""
    barrier_type: LegalBarrierType
    jurisdiction: str
    activation_count: int
    success_rate: float
    average_response_time: float
    bypass_attempts: int
    legal_challenges: int
    effectiveness_score: float
    last_updated: datetime

@dataclass
class ThreatActorProfile:
    """Profile of threat actor behavior regarding legal barriers"""
    actor_id: str
    ip_addresses: List[str]
    target_jurisdictions: List[str]
    barrier_interaction_patterns: Dict
    sophistication_level: str
    legal_evasion_techniques: List[str]
    response_to_barriers: str
    risk_assessment: str
    first_seen: datetime
    last_activity: datetime

class LegalBarrierMonitor:
    """Real-time monitoring system for legal barriers"""
    
    def __init__(self, legal_controller: LegalBarrierController):
        self.legal_controller = legal_controller
        self.active_monitoring = False
        self.alert_queue: deque = deque(maxlen=1000)
        self.effectiveness_metrics: Dict[str, BarrierEffectivenessMetrics] = {}
        self.threat_actor_profiles: Dict[str, ThreatActorProfile] = {}
        self.monitoring_rules: Dict[str, Callable] = {}
        self.websocket_clients: Set = set()
        self.alert_callbacks: List[Callable] = []
        
        # Initialize monitoring rules
        self._initialize_monitoring_rules()
    
    def _initialize_monitoring_rules(self):
        """Initialize monitoring rules for different scenarios"""
        
        self.monitoring_rules = {
            "barrier_effectiveness": self._monitor_barrier_effectiveness,
            "bypass_attempts": self._monitor_bypass_attempts,
            "jurisdiction_changes": self._monitor_jurisdiction_changes,
            "compliance_status": self._monitor_compliance_status,
            "threat_actor_patterns": self._monitor_threat_actor_patterns,
            "legal_challenges": self._monitor_legal_challenges,
            "system_performance": self._monitor_system_performance
        }
    
    async def start_monitoring(self):
        """Start real-time monitoring of legal barriers"""
        
        if self.active_monitoring:
            logger.warning("Legal monitoring already active")
            return
        
        self.active_monitoring = True
        logger.info("Starting real-time legal barrier monitoring")
        
        # Start monitoring tasks
        monitoring_tasks = [
            asyncio.create_task(self._monitoring_loop()),
            asyncio.create_task(self._alert_processing_loop()),
            asyncio.create_task(self._metrics_collection_loop()),
            asyncio.create_task(self._websocket_server())
        ]
        
        try:
            await asyncio.gather(*monitoring_tasks)
        except asyncio.CancelledError:
            logger.info("Legal monitoring stopped")
        except Exception as e:
            logger.error(f"Legal monitoring error: {e}")
            await self.stop_monitoring()
    
    async def stop_monitoring(self):
        """Stop legal barrier monitoring"""
        
        self.active_monitoring = False
        
        # Close websocket connections
        for client in self.websocket_clients.copy():
            await client.close()
        
        logger.info("Legal barrier monitoring stopped")
    
    async def _monitoring_loop(self):
        """Main monitoring loop"""
        
        while self.active_monitoring:
            try:
                # Execute all monitoring rules
                for rule_name, rule_func in self.monitoring_rules.items():
                    try:
                        await rule_func()
                    except Exception as e:
                        logger.error(f"Monitoring rule {rule_name} failed: {e}")
                
                # Sleep between monitoring cycles
                await asyncio.sleep(5)  # Monitor every 5 seconds
                
            except Exception as e:
                logger.error(f"Monitoring loop error: {e}")
                await asyncio.sleep(10)
    
    async def _alert_processing_loop(self):
        """Process alerts and send notifications"""
        
        while self.active_monitoring:
            try:
                if self.alert_queue:
                    alert = self.alert_queue.popleft()
                    await self._process_alert(alert)
                else:
                    await asyncio.sleep(1)
            except Exception as e:
                logger.error(f"Alert processing error: {e}")
                await asyncio.sleep(5)
    
    async def _metrics_collection_loop(self):
        """Collect and update effectiveness metrics"""
        
        while self.active_monitoring:
            try:
                await self._collect_effectiveness_metrics()
                await asyncio.sleep(30)  # Update metrics every 30 seconds
            except Exception as e:
                logger.error(f"Metrics collection error: {e}")
                await asyncio.sleep(60)
    
    async def _monitor_barrier_effectiveness(self):
        """Monitor the effectiveness of legal barriers"""
        
        # Analyze recent barrier activations
        recent_events = self.legal_controller.export_event_log(
            since=datetime.now(timezone.utc) - timedelta(minutes=5)
        )
        
        for event in recent_events:
            barrier_key = f"{event['barrier_type']}_{event['source_jurisdiction']}"
            
            if barrier_key not in self.effectiveness_metrics:
                self.effectiveness_metrics[barrier_key] = BarrierEffectivenessMetrics(
                    barrier_type=LegalBarrierType(event['barrier_type']),
                    jurisdiction=event['source_jurisdiction'],
                    activation_count=0,
                    success_rate=0.0,
                    average_response_time=0.0,
                    bypass_attempts=0,
                    legal_challenges=0,
                    effectiveness_score=0.0,
                    last_updated=datetime.now(timezone.utc)
                )
            
            metrics = self.effectiveness_metrics[barrier_key]
            metrics.activation_count += 1
            metrics.last_updated = datetime.now(timezone.utc)
            
            # Calculate effectiveness score (simplified)
            metrics.effectiveness_score = min(
                100.0, 
                (metrics.activation_count * 10) - (metrics.bypass_attempts * 20)
            )
            
            # Generate alert if effectiveness is low
            if metrics.effectiveness_score < 30:
                await self._generate_alert(
                    AlertType.EFFECTIVENESS_DEGRADATION,
                    MonitoringPriority.HIGH,
                    event['source_jurisdiction'],
                    LegalBarrierType(event['barrier_type']),
                    f"Legal barrier effectiveness degraded: {metrics.effectiveness_score:.1f}%",
                    {
                        "activation_count": metrics.activation_count,
                        "bypass_attempts": metrics.bypass_attempts,
                        "effectiveness_score": metrics.effectiveness_score
                    }
                )
    
    async def _monitor_bypass_attempts(self):
        """Monitor for attempts to bypass legal barriers"""
        
        # This would analyze network traffic patterns, repeated attempts
        # from same sources, etc. Simplified implementation for demo
        
        # Simulate detection of bypass attempts
        if secrets.randbelow(1000) < 5:  # 0.5% chance per monitoring cycle
            
            # Create alert for bypass attempt
            await self._generate_alert(
                AlertType.BARRIER_BYPASS_ATTEMPT,
                MonitoringPriority.CRITICAL,
                "US",  # Example jurisdiction
                LegalBarrierType.JURISDICTIONAL_ROUTING,
                "Potential legal barrier bypass attempt detected",
                {
                    "attack_pattern": "repeated_jurisdiction_probing",
                    "source_ips": ["192.168.1.100", "10.0.0.50"],
                    "bypass_technique": "jurisdiction_shopping"
                }
            )
    
    async def _monitor_jurisdiction_changes(self):
        """Monitor for changes in jurisdiction configurations"""
        
        current_status = self.legal_controller.get_jurisdiction_status()
        
        # This would compare with previous state to detect changes
        # For demo, we'll check for newly activated jurisdictions
        
        active_jurisdictions = [
            code for code, info in current_status["jurisdictions"].items()
            if info["mode"] == "active"
        ]
        
        if len(active_jurisdictions) > 3:  # Threshold for alert
            await self._generate_alert(
                AlertType.JURISDICTION_CHANGE,
                MonitoringPriority.MEDIUM,
                "SYSTEM",
                None,
                f"High number of active jurisdictions: {len(active_jurisdictions)}",
                {
                    "active_jurisdictions": active_jurisdictions,
                    "total_jurisdictions": len(current_status["jurisdictions"]),
                    "system_enabled": current_status["system_enabled"]
                }
            )
    
    async def _monitor_compliance_status(self):
        """Monitor compliance with legal requirements"""
        
        # Check system configuration compliance
        system_status = self.legal_controller.get_jurisdiction_status()
        
        compliance_issues = []
        
        # Check if system is enabled without proper jurisdictions
        if system_status["system_enabled"] and system_status["active_jurisdictions"] == 0:
            compliance_issues.append("System enabled but no active jurisdictions")
        
        # Check for conflicting jurisdiction configurations
        active_jurisdictions = [
            info for info in system_status["jurisdictions"].values()
            if info["mode"] == "active"
        ]
        
        if len(active_jurisdictions) > 1:
            # Check for treaty conflicts (simplified)
            us_active = any(j for j in active_jurisdictions if "US" in str(j))
            eu_active = any(j for j in active_jurisdictions if "EU" in str(j))
            
            if us_active and eu_active:
                compliance_issues.append("Potential US-EU data transfer compliance issue")
        
        # Generate compliance alerts
        for issue in compliance_issues:
            await self._generate_alert(
                AlertType.COMPLIANCE_VIOLATION,
                MonitoringPriority.HIGH,
                "SYSTEM",
                None,
                f"Compliance issue detected: {issue}",
                {
                    "compliance_issue": issue,
                    "active_jurisdictions": len(active_jurisdictions),
                    "remediation_required": True
                }
            )
    
    async def _monitor_threat_actor_patterns(self):
        """Monitor threat actor behavior patterns"""
        
        # Analyze threat actor interactions with legal barriers
        # This is a simplified implementation for demonstration
        
        # Simulate threat actor profiling
        if secrets.randbelow(1000) < 3:  # 0.3% chance per cycle
            
            actor_id = f"ACTOR_{secrets.token_hex(4)}"
            
            # Create threat actor profile
            profile = ThreatActorProfile(
                actor_id=actor_id,
                ip_addresses=[f"192.168.{secrets.randbelow(255)}.{secrets.randbelow(255)}"],
                target_jurisdictions=["US", "EU"],
                barrier_interaction_patterns={
                    "jurisdiction_probing": True,
                    "barrier_testing": True,
                    "evasion_attempts": 3
                },
                sophistication_level="HIGH",
                legal_evasion_techniques=["jurisdiction_shopping", "treaty_exploitation"],
                response_to_barriers="adaptive",
                risk_assessment="CRITICAL",
                first_seen=datetime.now(timezone.utc),
                last_activity=datetime.now(timezone.utc)
            )
            
            self.threat_actor_profiles[actor_id] = profile
            
            await self._generate_alert(
                AlertType.SYSTEM_ANOMALY,
                MonitoringPriority.HIGH,
                "MULTIPLE",
                None,
                f"Sophisticated threat actor detected: {actor_id}",
                {
                    "actor_id": actor_id,
                    "sophistication": profile.sophistication_level,
                    "risk_level": profile.risk_assessment,
                    "evasion_techniques": profile.legal_evasion_techniques
                }
            )
    
    async def _monitor_legal_challenges(self):
        """Monitor for potential legal challenges to barriers"""
        
        # This would monitor for:
        # - Court filings related to jurisdiction
        # - Regulatory challenges
        # - Policy changes affecting barriers
        
        # Simplified simulation
        if secrets.randbelow(10000) < 1:  # Very rare event
            
            await self._generate_alert(
                AlertType.LEGAL_CHALLENGE,
                MonitoringPriority.CRITICAL,
                "EU",
                LegalBarrierType.DATA_SOVEREIGNTY,
                "Potential legal challenge to data sovereignty barriers detected",
                {
                    "challenge_type": "regulatory_inquiry",
                    "jurisdiction": "EU",
                    "barrier_affected": "data_sovereignty",
                    "urgency": "immediate_review_required",
                    "legal_counsel_required": True
                }
            )
    
    async def _monitor_system_performance(self):
        """Monitor overall system performance and health"""
        
        # Monitor system metrics
        system_status = self.legal_controller.get_jurisdiction_status()
        
        performance_metrics = {
            "system_uptime": "99.9%",  # Would be calculated from actual uptime
            "response_time": "45ms",   # Average barrier activation time
            "memory_usage": "156MB",   # System memory usage
            "active_barriers": len([
                j for j in system_status["jurisdictions"].values()
                if j["mode"] == "active" and j["enabled_barriers"]
            ])
        }
        
        # Check for performance issues
        if performance_metrics["active_barriers"] > 10:
            await self._generate_alert(
                AlertType.SYSTEM_ANOMALY,
                MonitoringPriority.MEDIUM,
                "SYSTEM",
                None,
                f"High barrier load: {performance_metrics['active_barriers']} active barriers",
                performance_metrics
            )
    
    async def _generate_alert(self,
                            alert_type: AlertType,
                            priority: MonitoringPriority,
                            jurisdiction: str,
                            barrier_type: Optional[LegalBarrierType],
                            description: str,
                            context_data: Dict):
        """Generate monitoring alert"""
        
        alert = LegalMonitoringAlert(
            alert_id=secrets.token_hex(16),
            timestamp=datetime.now(timezone.utc),
            alert_type=alert_type,
            priority=priority,
            jurisdiction=jurisdiction,
            barrier_type=barrier_type,
            threat_actor_ip=context_data.get("source_ip"),
            description=description,
            automated_response=self._determine_automated_response(alert_type, priority),
            requires_human_review=priority in [MonitoringPriority.HIGH, MonitoringPriority.CRITICAL],
            legal_implications=self._assess_legal_implications(alert_type, jurisdiction),
            recommended_actions=self._generate_recommended_actions(alert_type, priority),
            context_data=context_data
        )
        
        self.alert_queue.append(alert)
        logger.info(f"Generated alert: {alert_type.value} - {priority.value} - {description}")
    
    def _determine_automated_response(self, alert_type: AlertType, priority: MonitoringPriority) -> Optional[str]:
        """Determine appropriate automated response"""
        
        responses = {
            AlertType.BARRIER_BYPASS_ATTEMPT: "increase_barrier_strength",
            AlertType.EFFECTIVENESS_DEGRADATION: "rotate_barrier_configuration",
            AlertType.COMPLIANCE_VIOLATION: "disable_conflicting_barriers",
            AlertType.SYSTEM_ANOMALY: "system_health_check"
        }
        
        if priority == MonitoringPriority.CRITICAL:
            return responses.get(alert_type, "escalate_to_human")
        else:
            return responses.get(alert_type)
    
    def _assess_legal_implications(self, alert_type: AlertType, jurisdiction: str) -> str:
        """Assess legal implications of alert"""
        
        implications = {
            AlertType.LEGAL_CHALLENGE: f"Potential legal action in {jurisdiction} - immediate counsel required",
            AlertType.COMPLIANCE_VIOLATION: f"Regulatory compliance issue in {jurisdiction} - remediation needed", 
            AlertType.BARRIER_BYPASS_ATTEMPT: f"Security effectiveness compromised in {jurisdiction}",
            AlertType.EFFECTIVENESS_DEGRADATION: f"Legal protection weakened in {jurisdiction}"
        }
        
        return implications.get(alert_type, f"Standard monitoring alert for {jurisdiction}")
    
    def _generate_recommended_actions(self, alert_type: AlertType, priority: MonitoringPriority) -> List[str]:
        """Generate recommended actions for alert"""
        
        action_map = {
            AlertType.BARRIER_ACTIVATION: [
                "Monitor barrier effectiveness",
                "Log activation for compliance audit"
            ],
            AlertType.BARRIER_BYPASS_ATTEMPT: [
                "Analyze attack patterns",
                "Strengthen barrier configuration", 
                "Consider additional jurisdictions",
                "Alert legal counsel if persistent"
            ],
            AlertType.COMPLIANCE_VIOLATION: [
                "Review jurisdiction configuration",
                "Consult compliance documentation",
                "Disable conflicting barriers if necessary",
                "Schedule compliance audit"
            ],
            AlertType.LEGAL_CHALLENGE: [
                "Immediate legal counsel consultation",
                "Preserve evidence and documentation",
                "Review barrier legitimacy",
                "Prepare legal response strategy"
            ],
            AlertType.EFFECTIVENESS_DEGRADATION: [
                "Analyze degradation causes",
                "Rotate barrier configurations",
                "Consider alternative jurisdictions",
                "Update effectiveness metrics"
            ]
        }
        
        actions = action_map.get(alert_type, ["Review alert details", "Take appropriate action"])
        
        if priority == MonitoringPriority.CRITICAL:
            actions.insert(0, "IMMEDIATE ACTION REQUIRED")
        
        return actions
    
    async def _process_alert(self, alert: LegalMonitoringAlert):
        """Process and respond to alert"""
        
        # Log alert
        logger.info(f"Processing alert {alert.alert_id}: {alert.description}")
        
        # Execute automated response if available
        if alert.automated_response:
            await self._execute_automated_response(alert)
        
        # Send notifications
        await self._send_alert_notifications(alert)
        
        # Call registered callbacks
        for callback in self.alert_callbacks:
            try:
                await callback(alert)
            except Exception as e:
                logger.error(f"Alert callback error: {e}")
    
    async def _execute_automated_response(self, alert: LegalMonitoringAlert):
        """Execute automated response to alert"""
        
        response_actions = {
            "increase_barrier_strength": self._increase_barrier_strength,
            "rotate_barrier_configuration": self._rotate_barrier_configuration,
            "disable_conflicting_barriers": self._disable_conflicting_barriers,
            "system_health_check": self._system_health_check
        }
        
        action = response_actions.get(alert.automated_response)
        if action:
            try:
                await action(alert)
                logger.info(f"Executed automated response: {alert.automated_response}")
            except Exception as e:
                logger.error(f"Automated response failed: {e}")
    
    async def _increase_barrier_strength(self, alert: LegalMonitoringAlert):
        """Increase barrier strength in response to bypass attempts"""
        
        # Add additional barrier types to affected jurisdiction
        if alert.jurisdiction != "SYSTEM":
            jurisdiction = self.legal_controller.jurisdiction_db.get_jurisdiction(alert.jurisdiction)
            if jurisdiction and jurisdiction.mode == JurisdictionMode.ACTIVE:
                
                # Add additional barriers
                new_barriers = [
                    LegalBarrierType.LEGAL_STANDING_COMPLEXITY,
                    LegalBarrierType.EVIDENCE_CHAIN_PROTECTION
                ]
                
                for barrier in new_barriers:
                    if barrier not in jurisdiction.barrier_types_enabled:
                        jurisdiction.barrier_types_enabled.append(barrier)
                
                self.legal_controller.jurisdiction_db.update_jurisdiction(
                    alert.jurisdiction, jurisdiction
                )
                
                logger.info(f"Increased barrier strength for {alert.jurisdiction}")
    
    async def _rotate_barrier_configuration(self, alert: LegalMonitoringAlert):
        """Rotate barrier configuration to maintain effectiveness"""
        
        # This would implement barrier rotation logic
        # For demo, we'll just log the action
        logger.info(f"Rotating barrier configuration for {alert.jurisdiction}")
    
    async def _disable_conflicting_barriers(self, alert: LegalMonitoringAlert):
        """Disable conflicting barriers to ensure compliance"""
        
        # This would implement conflict resolution logic
        logger.info(f"Resolving barrier conflicts for {alert.jurisdiction}")
    
    async def _system_health_check(self, alert: LegalMonitoringAlert):
        """Perform system health check"""
        
        # Check system status and performance
        status = self.legal_controller.get_jurisdiction_status()
        logger.info(f"System health check: {len(status['jurisdictions'])} jurisdictions configured")
    
    async def _send_alert_notifications(self, alert: LegalMonitoringAlert):
        """Send alert notifications to connected clients"""
        
        # Send to websocket clients
        alert_data = asdict(alert)
        alert_data['timestamp'] = alert.timestamp.isoformat()
        
        # Convert enums to strings for JSON serialization
        alert_data['alert_type'] = alert.alert_type.value
        alert_data['priority'] = alert.priority.value
        if alert.barrier_type:
            alert_data['barrier_type'] = alert.barrier_type.value
        
        message = json.dumps({
            "type": "alert",
            "data": alert_data
        })
        
        # Send to all connected websocket clients
        for client in self.websocket_clients.copy():
            try:
                await client.send(message)
            except Exception as e:
                logger.warning(f"Failed to send alert to client: {e}")
                self.websocket_clients.discard(client)
    
    async def _collect_effectiveness_metrics(self):
        """Collect and update barrier effectiveness metrics"""
        
        # Update metrics for all active barriers
        for barrier_key, metrics in self.effectiveness_metrics.items():
            
            # Calculate updated effectiveness score
            # This would involve complex analysis of barrier performance
            
            # For demo, simulate metric updates
            if secrets.randbelow(100) < 10:  # 10% chance of metric change
                metrics.effectiveness_score = max(
                    0.0, 
                    metrics.effectiveness_score + secrets.randbelow(20) - 10
                )
                metrics.last_updated = datetime.now(timezone.utc)
    
    async def _websocket_server(self):
        """WebSocket server for real-time monitoring updates"""
        
        async def handle_client(websocket, path):
            """Handle individual websocket client"""
            
            self.websocket_clients.add(websocket)
            logger.info(f"Legal monitoring client connected: {websocket.remote_address}")
            
            try:
                # Send initial status
                status = self.legal_controller.get_jurisdiction_status()
                await websocket.send(json.dumps({
                    "type": "status",
                    "data": status
                }))
                
                # Keep connection alive
                async for message in websocket:
                    # Handle client messages if needed
                    data = json.loads(message)
                    await self._handle_client_message(websocket, data)
                    
            except websockets.exceptions.ConnectionClosed:
                logger.info("Legal monitoring client disconnected")
            except Exception as e:
                logger.error(f"WebSocket client error: {e}")
            finally:
                self.websocket_clients.discard(websocket)
        
        # Start WebSocket server on port 8766
        try:
            start_server = websockets.serve(handle_client, "localhost", 8766)
            await start_server
            logger.info("Legal monitoring WebSocket server started on ws://localhost:8766")
        except Exception as e:
            logger.error(f"Failed to start WebSocket server: {e}")
    
    async def _handle_client_message(self, websocket, data: Dict):
        """Handle messages from websocket clients"""
        
        message_type = data.get("type")
        
        if message_type == "get_metrics":
            # Send effectiveness metrics
            metrics_data = {
                barrier_key: asdict(metrics) 
                for barrier_key, metrics in self.effectiveness_metrics.items()
            }
            
            await websocket.send(json.dumps({
                "type": "metrics",
                "data": metrics_data
            }))
        
        elif message_type == "get_alerts":
            # Send recent alerts
            recent_alerts = list(self.alert_queue)[-10:]  # Last 10 alerts
            
            alert_data = []
            for alert in recent_alerts:
                alert_dict = asdict(alert)
                alert_dict['timestamp'] = alert.timestamp.isoformat()
                alert_dict['alert_type'] = alert.alert_type.value
                alert_dict['priority'] = alert.priority.value
                if alert.barrier_type:
                    alert_dict['barrier_type'] = alert.barrier_type.value
                alert_data.append(alert_dict)
            
            await websocket.send(json.dumps({
                "type": "alerts",
                "data": alert_data
            }))
    
    def add_alert_callback(self, callback: Callable):
        """Add callback function for alert notifications"""
        self.alert_callbacks.append(callback)
    
    def get_recent_alerts(self, limit: int = 50) -> List[LegalMonitoringAlert]:
        """Get recent monitoring alerts"""
        return list(self.alert_queue)[-limit:]
    
    def get_effectiveness_metrics(self) -> Dict[str, BarrierEffectivenessMetrics]:
        """Get current effectiveness metrics"""
        return self.effectiveness_metrics.copy()
    
    def get_threat_actor_profiles(self) -> Dict[str, ThreatActorProfile]:
        """Get threat actor profiles"""
        return self.threat_actor_profiles.copy()

# Integration with MWRASP quantum attack detection
class IntegratedLegalMonitoring:
    """Integration layer between quantum attack detection and legal monitoring"""
    
    def __init__(self):
        self.legal_controller = LegalBarrierController()
        self.legal_monitor = LegalBarrierMonitor(self.legal_controller)
        
    async def start_integrated_monitoring(self):
        """Start integrated quantum attack detection and legal monitoring"""
        
        logger.info("Starting integrated quantum attack detection and legal monitoring")
        
        # Start legal monitoring
        monitoring_task = asyncio.create_task(self.legal_monitor.start_monitoring())
        
        # Start quantum attack detection monitoring (would integrate with main MWRASP system)
        quantum_monitoring_task = asyncio.create_task(self._quantum_attack_monitoring_loop())
        
        await asyncio.gather(monitoring_task, quantum_monitoring_task)
    
    async def _quantum_attack_monitoring_loop(self):
        """Monitor quantum attacks and trigger legal barriers"""
        
        while True:
            try:
                # Simulate quantum attack detection
                if secrets.randbelow(1000) < 2:  # 0.2% chance per cycle
                    
                    # Simulate quantum attack data
                    attack_data = {
                        "classification": "quantum_attack",
                        "algorithm": secrets.choice(["Shor_Algorithm", "Grover_Search", "QFT_Pattern"]),
                        "severity": secrets.choice(["HIGH", "CRITICAL"]),
                        "source_ip": f"192.168.{secrets.randbelow(255)}.{secrets.randbelow(255)}",
                        "target": "encryption_system"
                    }
                    
                    # Process with legal barriers
                    legal_response = await self.legal_controller.process_threat_with_legal_barriers(
                        attack_data, attack_data["source_ip"]
                    )
                    
                    logger.info(f"Quantum attack detected - Legal barriers activated: {len(legal_response['legal_barriers'])}")
                
                await asyncio.sleep(10)  # Check every 10 seconds
                
            except Exception as e:
                logger.error(f"Quantum attack monitoring error: {e}")
                await asyncio.sleep(30)

# Demo function
async def demo_legal_monitoring():
    """Demonstrate real-time legal monitoring system"""
    
    print("\n" + "="*80)
    print("MWRASP REAL-TIME LEGAL BARRIER MONITORING DEMONSTRATION")
    print("Continuous monitoring and alerting for legal barrier effectiveness")
    print("="*80)
    
    # Initialize integrated monitoring
    integrated_monitor = IntegratedLegalMonitoring()
    
    # Enable legal barrier system
    auth_key = "authorized_legal_barrier_activation"
    if integrated_monitor.legal_controller.enable_system(auth_key):
        print("✅ Legal Barrier System ENABLED")
    
    # Configure some jurisdictions
    integrated_monitor.legal_controller.configure_jurisdiction(
        "US", JurisdictionMode.ACTIVE, 
        [LegalBarrierType.DATA_SOVEREIGNTY, LegalBarrierType.COMPLIANCE_FRAGMENTATION]
    )
    
    integrated_monitor.legal_controller.configure_jurisdiction(
        "EU", JurisdictionMode.ACTIVE,
        [LegalBarrierType.LEGAL_STANDING_COMPLEXITY]
    )
    
    print("✅ Jurisdictions configured for monitoring")
    
    # Add alert callback for demonstration
    async def demo_alert_callback(alert: LegalMonitoringAlert):
        print(f"\n🚨 ALERT: {alert.alert_type.value.upper()}")
        print(f"   Priority: {alert.priority.value.upper()}")
        print(f"   Description: {alert.description}")
        print(f"   Jurisdiction: {alert.jurisdiction}")
        if alert.recommended_actions:
            print(f"   Recommended Actions: {', '.join(alert.recommended_actions[:2])}")
    
    integrated_monitor.legal_monitor.add_alert_callback(demo_alert_callback)
    
    print(f"\n🔍 Starting real-time legal monitoring...")
    print("📡 WebSocket server available at ws://localhost:8766")
    print("🌐 Legal barrier configuration interface available")
    print("\n⏳ Monitoring for 60 seconds (press Ctrl+C to stop early)...")
    
    try:
        # Run monitoring for demonstration
        await asyncio.wait_for(
            integrated_monitor.start_integrated_monitoring(),
            timeout=60.0
        )
    except asyncio.TimeoutError:
        print("\n⏰ Monitoring demonstration complete")
    except KeyboardInterrupt:
        print("\n⏹️ Monitoring stopped by user")
    
    # Show final statistics
    alerts = integrated_monitor.legal_monitor.get_recent_alerts(10)
    metrics = integrated_monitor.legal_monitor.get_effectiveness_metrics()
    
    print(f"\n📊 MONITORING SUMMARY:")
    print(f"   Alerts Generated: {len(alerts)}")
    print(f"   Effectiveness Metrics: {len(metrics)}")
    print(f"   WebSocket Clients: {len(integrated_monitor.legal_monitor.websocket_clients)}")
    
    # Show recent alerts
    if alerts:
        print(f"\n📋 Recent Alerts:")
        for alert in alerts[-3:]:
            print(f"   • {alert.timestamp.strftime('%H:%M:%S')}: {alert.alert_type.value} - {alert.priority.value}")
    
    await integrated_monitor.legal_monitor.stop_monitoring()
    print("\n✅ Legal monitoring demonstration complete")

if __name__ == "__main__":
    # Run demonstration
    asyncio.run(demo_legal_monitoring())